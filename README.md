# rules_crystal

**EXPERIMENTAL** Crystal rules for Bazel.

## Usage

### Basics

Add this to your WORKSPACE:

```starlark
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

http_archive(
    name = "rules_crystal",
    urls = ["https://github.com/refi64/rules_crystal/archive/COMMIT"],
    sha256 = "SHA256",
)

load("@rules_crystal//:index.bzl", "crystal_repositories")

crystal_repositories(name = "crystal")
```

setting `COMMIT` to a commit of this repository and `SHA256` to the checksum of said
archive.

Now you can use the various rules in your `BUILD` files:

```starlark
load("@rules_crystal//:index.bzl", "crystal_binary")

crystal_binary(
    name = "myapp",
    srcs = glob(["src/**/*.cr"]),
    main = "src/myapp.cr",
)
```

## Usage with shards

You can use dependencies from your `shard.yml` as well. Update your WORKSPACE file to
add `managed_directories` to the top, then use the `shards_install` rule:

```starlark
workspace(
    name = "myapp",
    managed_directories = {"@shards": ["lib"]},
)

# ...

load("@rules_crystal//:index.bzl", "crystal_repositories", "shards_install")

crystal_repositories(name = "crystal")

shards_install(
    name = "shards",
    shard_lock = "//:shard.lock",
    shard_yml = "//:shard.yml",
)
```

Note that this will run shards with `--frozen`, i.e. it will use dependencies from your
`shard.lock`. If you've added or modified dependencies and want to update the lockfile,
you can run shards directly via `bazel run @crystal//:bin/shards`.

Now, we can use the shards within our BUILD file:

```starlark
load("@rules_crystal//:index.bzl", "crystal_binary")

crystal_binary(
    name = "myapp",
    srcs = glob(["src/**/*.cr"]),
    main = "src/myapp.cr",
    deps = ["@shards//:some-shard-name-here"],
)
```

### Testing

You can use the `crystal_test` rule to run unit tests:

```starlark
load("@rules_crystal//:index.bzl", "crystal_binary", "crystal_test")

crystal_binary(
    name = "myapp",
    srcs = glob(["src/**/*.cr"]),
    main = "src/myapp.cr",
    deps = ["@shards//:some-shard-name-here"],
)

crystal_test(
    name = "spec",
    srcs = glob(["spec/**/*.cr"]),
    subject = ":myapp",
)
```

Note the attribute `subject`. This will pull the sources and deps from `crystal_binary`
and use those to build the tests as well. In other words, the above is functionally
equivalent to:

```starlark
load("@rules_crystal//:index.bzl", "crystal_binary", "crystal_test")

crystal_binary(
    name = "myapp",
    srcs = glob(["src/**/*.cr"]),
    main = "src/myapp.cr",
    deps = ["@shards//:some-shard-name-here"],
)

crystal_test(
    name = "spec",
    srcs = glob(
        [
            "src/**/*.cr",
            "spec/**/*.cr",
        ],
        # Automatically excludes the main entry point
        exclude = ["src/myapp.cr"],
    ),
    deps = ["@shards//:some-shard-name-here"],
)
```

## Examples

The following examples are available:

- [`basic`](examples/basic): Showcases a simple binary and some tests.
- [`generated`](examples/generated): Has a source file that was generated by another rule.
  Notice that a symlink was created in the source tree at the location of the generated
  file so that autocomplete works.
- [`kemal`](examples/kemal): Uses the Kemal shard, showcasing `shards` integration.

## Notable gotchas

### Empty directories

Normally, this code is valid if `dir` is empty, as long as it is present:

```crystal
require './dir/**'
```

However, in the Bazel sandbox, empty directories will not be preserved, so this will be an
error.

A workaround is to have `.keep` files inside the directory, then use those in
`extra_srcs`, which will ensure the directories have at least one file and thus are kept
in the sandbox.

## Major TODOs

- Rendered documentation
- Figure out how to deal with `pkg-config`, C/C++ dependencies
